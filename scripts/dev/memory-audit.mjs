#!/usr/bin/env node
/**
 * Memory Audit
 *
 * Scans canonical rules and architecture/development docs to detect:
 * - Duplicate titles across locations
 * - Similar documents (content-based)
 * - Orphans (no counterpart in the other group)
 *
 * Outputs: docs/_generated/memory-audit.md
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT = path.join(__dirname, '..', '..');

const RULES_DIR = path.join(ROOT, '.windsurf', 'rules');
const ARCH_DIR = path.join(ROOT, 'docs', 'architecture');
const DEV_DIR = path.join(ROOT, 'docs', 'development');
const OUT_DIR = path.join(ROOT, 'docs', '_generated');
const OUT_FILE = path.join(OUT_DIR, 'memory-audit.md');

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function listFilesRecursive(dir, ext = '.md') {
  const out = [];
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const e of entries) {
      const p = path.join(dir, e.name);
      if (e.isDirectory()) out.push(...listFilesRecursive(p, ext));
      else if (e.isFile() && p.endsWith(ext)) out.push(p);
    }
  } catch {
    /* ignore missing dirs */
  }
  return out;
}

function readFileSafe(fp) {
  try {
    return fs.readFileSync(fp, 'utf-8');
  } catch {
    return '';
  }
}

function stripFrontMatter(src) {
  const m = src.match(/^---\n([\s\S]*?)\n---\n?/);
  return m ? src.slice(m[0].length) : src;
}

function firstHeading(md) {
  const lines = md.split(/\r?\n/);
  for (const line of lines) {
    const m = line.match(/^#\s+(.+)/);
    if (m) return m[1].trim();
  }
  return '';
}

function normalizeTitle(s) {
  return (s || '')
    .toLowerCase()
    .replace(/`[^`]+`/g, '')
    .replace(/[^a-z0-9]+/g, ' ')
    .trim();
}

function contentTokens(md, maxChars = 2000) {
  const body = stripFrontMatter(md)
    .replace(/```[\s\S]*?```/g, ' ')
    .replace(/`[^`]+`/g, ' ')
    .slice(0, maxChars)
    .toLowerCase();
  return body.split(/[^a-z0-9]+/).filter(Boolean);
}

function jaccard(aTokens, bTokens) {
  const a = new Set(aTokens);
  const b = new Set(bTokens);
  const inter = new Set([...a].filter((t) => b.has(t)));
  const union = new Set([...a, ...b]);
  return union.size === 0 ? 0 : inter.size / union.size;
}

function rel(p) {
  return path.relative(ROOT, p).replace(/\\/g, '/');
}

function buildDocsGroup(label, files) {
  return files.map((fp) => {
    const raw = readFileSafe(fp);
    const nofm = stripFrontMatter(raw);
    const title = firstHeading(nofm) || path.basename(fp, '.md');
    return {
      label,
      path: rel(fp),
      title,
      normTitle: normalizeTitle(title),
      tokens: contentTokens(nofm),
    };
  });
}

function generateReport({ rules, arch, dev, dupTitleGroups, similarPairs, orphans }) {
  const lines = [];
  lines.push('<!-- Generated by scripts/dev/memory-audit.mjs -->');
  lines.push('# Memory Audit');
  lines.push('');
  lines.push('This report highlights duplicated titles, similar documents, and orphans between canonical rules and architecture/development docs.');
  lines.push('');

  lines.push('## Duplicate titles');
  lines.push('');
  if (dupTitleGroups.length === 0) lines.push('- None');
  else {
    for (const g of dupTitleGroups) {
      lines.push(`- **${g.key}**`);
      for (const it of g.items) lines.push(`  - ${it.label}: ${it.path}`);
    }
  }
  lines.push('');

  lines.push('## Similar documents (content-based)');
  lines.push('');
  if (similarPairs.length === 0) lines.push('- None');
  else {
    for (const p of similarPairs) {
      lines.push(`- (${(p.similarity * 100).toFixed(0)}%) ${p.a.label}: ${p.a.path}`);
      lines.push(`  ↳ ${p.b.label}: ${p.b.path}`);
    }
  }
  lines.push('');

  lines.push('## Orphans');
  lines.push('');
  lines.push('- Rules with no close counterpart:');
  if (orphans.rules.length === 0) lines.push('  - None');
  else for (const r of orphans.rules) lines.push(`  - ${r.path}`);
  lines.push('');
  lines.push('- Docs with no close counterpart:');
  if (orphans.docs.length === 0) lines.push('  - None');
  else for (const d of orphans.docs) lines.push(`  - ${d.path}`);
  lines.push('');

  lines.push('## Summary');
  lines.push('');
  lines.push(`- Rules scanned: ${rules.length}`);
  lines.push(`- Arch docs scanned: ${arch.length}`);
  lines.push(`- Dev docs scanned: ${dev.length}`);
  lines.push(`- Duplicate title groups: ${dupTitleGroups.length}`);
  lines.push(`- Similar pairs: ${similarPairs.length}`);
  lines.push('');

  lines.push('## Regenerate');
  lines.push('');
  lines.push('```sh');
  lines.push('npm run mem:audit');
  lines.push('```');
  lines.push('');

  return lines.join('\n');
}

async function main() {
  ensureDir(OUT_DIR);
  const ruleFiles = listFilesRecursive(RULES_DIR);
  const archFiles = listFilesRecursive(ARCH_DIR);
  const devFiles = listFilesRecursive(DEV_DIR);

  const rules = buildDocsGroup('rules', ruleFiles);
  const arch = buildDocsGroup('arch', archFiles);
  const dev = buildDocsGroup('dev', devFiles);
  const docs = [...arch, ...dev];

  // Duplicate titles across all groups
  const byTitle = new Map();
  for (const x of [...rules, ...docs]) {
    const key = x.normTitle;
    if (!key) continue;
    if (!byTitle.has(key)) byTitle.set(key, []);
    byTitle.get(key).push(x);
  }
  const dupTitleGroups = [...byTitle.entries()]
    .filter(([, arr]) => arr.length > 1)
    .map(([key, arr]) => ({ key, items: arr }));

  // Similar pairs (rules vs docs only)
  const similarPairs = [];
  for (const r of rules) {
    for (const d of docs) {
      const sim = jaccard(r.tokens, d.tokens);
      if (sim >= 0.6) {
        similarPairs.push({ a: r, b: d, similarity: sim });
      }
    }
  }
  similarPairs.sort((a, b) => b.similarity - a.similarity);

  // Orphans (no similar doc >= threshold)
  const rulesWithMatch = new Set(similarPairs.map((p) => p.a.path));
  const docsWithMatch = new Set(similarPairs.map((p) => p.b.path));
  const orphans = {
    rules: rules.filter((r) => !rulesWithMatch.has(r.path)),
    docs: docs.filter((d) => !docsWithMatch.has(d.path)),
  };

  const report = generateReport({ rules, arch, dev, dupTitleGroups, similarPairs, orphans });
  fs.writeFileSync(OUT_FILE, report);
  console.log(
    `✓ Wrote ${rel(OUT_FILE)} (rules: ${rules.length}, arch: ${arch.length}, dev: ${dev.length}, dup-title-groups: ${dupTitleGroups.length}, similar: ${similarPairs.length})`
  );
}

main().catch((err) => {
  console.error('Failed to audit memories:', err);
  process.exit(1);
});
