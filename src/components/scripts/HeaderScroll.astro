---
// Separate Client-Script Component fÃ¼r den Header Scroll-Effekt
// Optimiert fÃ¼r Performance und Robustheit
---

<script>
  /**
   * HeaderScroll - Optimierter Header-Animation fÃ¼r Show/Hide beim Scrollen
   * - Verbesserte Performance durch RequestAnimationFrame
   * - Optimierte Scroll-Erkennung mit Schwellenwert und VerzÃ¶gerung
   * - Reduzierte DOM-Zugriffe
   * - Verwendet funktionierendes Pattern ohne script-coordinator
   */
  
  // Direkte AusfÃ¼hrung ohne coordinator (funktionierendes Pattern aus Header.astro)
  function initHeaderScrollEffect() {
      console.log('[HeaderScroll] ðŸš€ Starting header scroll effect initialization...');
      
      // Header-Element mit detailliertem Logging suchen
      const header = document.getElementById('site-header');
      const headerByTag = document.querySelector('header');
      const headerByClass = document.querySelector('.header');
      
      console.log('[HeaderScroll] ðŸ” Header element detection results:', {
        headerById: !!header,
        headerByTag: !!headerByTag,
        headerByClass: !!headerByClass,
        headerClasses: header?.className || 'not found',
        headerTagName: header?.tagName || 'not found',
        allHeaders: Array.from(document.querySelectorAll('header')).map(h => ({
          id: h.id,
          classes: h.className,
          tagName: h.tagName
        }))
      });
      
      if (!header) {
        console.error('[HeaderScroll] âŒ Header element (#site-header) not found in DOM');
        console.log('[HeaderScroll] ðŸ” Available header-related elements:', {
          headerByTag: !!headerByTag,
          headerByClass: !!headerByClass,
          possibleHeaders: Array.from(document.querySelectorAll('[id*="header"], [class*="header"]')).map(el => ({
            id: el.id,
            classes: el.className,
            tagName: el.tagName
          }))
        });
        return;
      }
      
      // Variablen fÃ¼r Scroll-Logik
      let lastScrollY = window.scrollY;
      let ticking = false;
      let hideTimeout = null;
      const scrollThreshold = 60;     // FrÃ¼her reagieren
      const scrollDeltaThreshold = 5; // Mindestens 5px scrollen fÃ¼r Aktion
      
      // Header initial sichtbar machen
      header.classList.add('header-visible');
      header.classList.remove('header-hidden');
      
      function handleScroll() {
        const currentScrollY = window.scrollY;
        const scrollDelta = currentScrollY - lastScrollY;
        const scrollDirection = scrollDelta > 0 ? 'down' : 'up';
        
        console.log('[HeaderScroll] ðŸ“œ Scroll event detected:', {
          currentScrollY,
          lastScrollY,
          scrollDelta,
          scrollDirection,
          scrollThreshold,
          scrollDeltaThreshold,
          isAboveThreshold: currentScrollY <= scrollThreshold,
          isDeltaSignificant: Math.abs(scrollDelta) >= scrollDeltaThreshold
        });
        
        // Oberhalb des Thresholds oder am Seitenanfang - Header immer sichtbar
        if (currentScrollY <= scrollThreshold) {
          console.log('[HeaderScroll] ðŸ“œ Above threshold - keeping header visible');
          showHeader();
          lastScrollY = currentScrollY;
          ticking = false;
          return;
        }
        
        // Genug gescrollt fÃ¼r eine Aktion?
        if (Math.abs(currentScrollY - lastScrollY) < scrollDeltaThreshold) {
          console.log('[HeaderScroll] ðŸ“œ Scroll delta too small - ignoring');
          ticking = false;
          return;
        }
        
        // Nach unten scrollen - Header ausblenden mit VerzÃ¶gerung
        if (currentScrollY > lastScrollY) {
          console.log('[HeaderScroll] ðŸ“œ Scrolling down - scheduling header hide');
          
          // Bestehenden Timer lÃ¶schen wenn vorhanden
          if (hideTimeout) {
            console.log('[HeaderScroll] ðŸ“œ Clearing existing hide timeout');
            clearTimeout(hideTimeout);
          }
          
          // Kurze VerzÃ¶gerung vor dem Ausblenden fÃ¼r bessere UX
          hideTimeout = window.setTimeout(() => {
            console.log('[HeaderScroll] ðŸ“œ Hide timeout executed - hiding header');
            if (header) {
              header.classList.add('header-hidden');
              header.classList.remove('header-visible');
              console.log('[HeaderScroll] âœ… Header hidden successfully:', {
                headerClasses: header.className
              });
            }
            hideTimeout = null;
          }, 150);
        } 
        // Nach oben scrollen - Header sofort einblenden
        else {
          console.log('[HeaderScroll] ðŸ“œ Scrolling up - showing header immediately');
          
          if (hideTimeout) {
            console.log('[HeaderScroll] ðŸ“œ Clearing hide timeout for immediate show');
            clearTimeout(hideTimeout);
            hideTimeout = null;
          }
          showHeader();
        }
        
        lastScrollY = currentScrollY;
        ticking = false;
        
        console.log('[HeaderScroll] ðŸ“œ Scroll handling completed:', {
          newLastScrollY: lastScrollY,
          tickingReset: !ticking
        });
      }
      
      function showHeader() {
        console.log('[HeaderScroll] ðŸ“œ showHeader() called');
        if (header) {
          header.classList.add('header-visible');
          header.classList.remove('header-hidden');
          console.log('[HeaderScroll] âœ… Header shown successfully:', {
            headerClasses: header.className,
            hasVisibleClass: header.classList.contains('header-visible'),
            hasHiddenClass: header.classList.contains('header-hidden')
          });
        } else {
          console.error('[HeaderScroll] âŒ Cannot show header - header element is null');
        }
      }
      
      // Event-Handler fÃ¼r Cleanup speichern
      let scrollHandler: (() => void) | null = null;
      let resizeHandler: (() => void) | null = null;
      
      // Optimiertes Event-Handling mit requestAnimationFrame
      console.log('[HeaderScroll] ðŸ”— Setting up event listeners...');
      
      scrollHandler = function() {
        if (!ticking) {
          console.log('[HeaderScroll] ðŸ“œ Scroll event triggered - scheduling RAF');
          window.requestAnimationFrame(function() {
            handleScroll();
          });
          ticking = true;
        } else {
          console.log('[HeaderScroll] ðŸ“œ Scroll event throttled - already ticking');
        }
      };
      window.addEventListener('scroll', scrollHandler, { passive: true });
      console.log('[HeaderScroll] ðŸ”— Scroll event listener attached');
      
      // Resize-Event - Header neu positionieren
      resizeHandler = function() {
        if (!ticking) {
          console.log('[HeaderScroll] ðŸ“± Resize event triggered - scheduling RAF');
          window.requestAnimationFrame(function() {
            // Bei Resize immer Header zeigen
            showHeader();
            ticking = false;
          });
          ticking = true;
        } else {
          console.log('[HeaderScroll] ðŸ“± Resize event throttled - already ticking');
        }
      };
      window.addEventListener('resize', resizeHandler, { passive: true });
      console.log('[HeaderScroll] ðŸ”— Resize event listener attached');
      
      // Initial auslÃ¶sen
      console.log('[HeaderScroll] ðŸš€ Triggering initial handleScroll...');
      handleScroll();
      
      console.log('[HeaderScroll] âœ… Scroll effect initialized successfully with comprehensive logging:', {
        scrollThreshold,
        scrollDeltaThreshold,
        hasScrollHandler: !!scrollHandler,
        hasResizeHandler: !!resizeHandler,
        initialScrollY: window.scrollY,
        headerClasses: header.className,
        dependencies: ['header-mobile-menu'],
        timestamp: new Date().toISOString()
      });
      
      // Cleanup fÃ¼r Event-Listener global verfÃ¼gbar machen
      window.headerScrollCleanup = function() {
        if (scrollHandler) {
          window.removeEventListener('scroll', scrollHandler);
        }
        if (resizeHandler) {
          window.removeEventListener('resize', resizeHandler);
        }
        if (hideTimeout) {
          clearTimeout(hideTimeout);
        }
        console.log('[HeaderScroll] Scroll effect cleaned up');
      };
    }
  
  // Direkter Aufruf wenn DOM bereit ist (funktionierendes Pattern aus Header.astro)
  if (document.readyState !== 'loading') {
    initHeaderScrollEffect();
  } else {
    document.addEventListener('DOMContentLoaded', initHeaderScrollEffect);
  }
</script>

<!-- Dummy HTML node to force Astro script compilation/injection -->
<div style="display: none;" aria-hidden="true"></div>
