---
// Separate Client-Script Component fÃ¼r den Header Scroll-Effekt
// Optimiert fÃ¼r Performance und Robustheit
---

<script is:inline nonce={Astro.locals.cspNonce}>
  /**
   * HeaderScroll - Optimierter Header-Animation fÃ¼r Show/Hide beim Scrollen
   * - Verbesserte Performance durch RequestAnimationFrame
   * - Optimierte Scroll-Erkennung mit Schwellenwert und VerzÃ¶gerung
   * - Reduzierte DOM-Zugriffe
   * - Verwendet funktionierendes Pattern ohne script-coordinator
   */

  // Direkte AusfÃ¼hrung ohne coordinator (funktionierendes Pattern aus Header.astro)
  function initHeaderScrollEffect() {
    const __DEV__ =
      typeof location !== 'undefined' &&
      (location.hostname === 'localhost' || location.hostname === '127.0.0.1');
    const getFlag = () => {
      try {
        const ls = localStorage.getItem('debug.headerScroll') === '1';
        const qp = new URLSearchParams(location.search).has('debugHeader');
        return ls || qp;
      } catch {
        return false;
      }
    };
    const VERBOSE = __DEV__ && getFlag();
    const TRACE = __DEV__ && ((() => {
      try { return localStorage.getItem('debug.headerScrollTrace') === '1'; } catch { return false; }
    })());
    const dlog = (...args) => {
      if (VERBOSE) console.debug(...args);
    };
    const dinfo = (...args) => {
      if (VERBOSE) console.info(...args);
    };
    const dtrace = (...args) => {
      if (TRACE) console.debug(...args);
    };
    const dwarn = (...args) => {
      if (__DEV__) console.warn(...args);
    };
    dinfo('[HeaderScroll] ðŸš€ Starting header scroll effect initialization...');

    // Header-Element mit detailliertem Logging suchen
    const header = document.getElementById('site-header');
    const headerByTag = document.querySelector('header');
    const headerByClass = document.querySelector('.header');

    dlog('[HeaderScroll] ðŸ” Header element detection results:', {
      headerById: !!header,
      headerByTag: !!headerByTag,
      headerByClass: !!headerByClass,
      headerClasses: header?.className || 'not found',
      headerTagName: header?.tagName || 'not found',
      allHeaders: Array.from(document.querySelectorAll('header')).map((h) => ({
        id: h.id,
        classes: h.className,
        tagName: h.tagName,
      })),
    });

    if (!header) {
      console.error('[HeaderScroll] âŒ Header element (#site-header) not found in DOM');
      dlog('[HeaderScroll] ðŸ” Available header-related elements:', {
        headerByTag: !!headerByTag,
        headerByClass: !!headerByClass,
        possibleHeaders: Array.from(
          document.querySelectorAll('[id*="header"], [class*="header"]')
        ).map((el) => ({
          id: el.id,
          classes: el.className,
          tagName: el.tagName,
        })),
      });
      return;
    }

    // Variablen fÃ¼r Scroll-Logik
    let lastScrollY = window.scrollY;
    let ticking = false;
    let hideTimeout = null;
    const scrollThreshold = 80; // Reagiert etwas spÃ¤ter
    const scrollDeltaThreshold = 8; // Mindestens 8px scrollen fÃ¼r Aktion
    let isVisible = true;

    // Header initial sichtbar machen
    header.classList.add('header-visible');
    header.classList.remove('header-hidden');

    function applyHeaderBackground(y) {
      try {
        const scrolled = (typeof y === 'number' ? y : window.scrollY) > 10;
        if (scrolled) {
          header.classList.add('header-solid');
        } else {
          header.classList.remove('header-solid');
        }
      } catch (e) {
        dwarn('[HeaderScroll] âš ï¸ Failed to apply header background state:', e);
      }
    }

    function handleScroll() {
      const currentScrollY = window.scrollY;
      const scrollDelta = currentScrollY - lastScrollY;
      const scrollDirection = scrollDelta > 0 ? 'down' : 'up';

      dtrace('[HeaderScroll] ðŸ“œ Scroll event detected:', {
        currentScrollY,
        lastScrollY,
        scrollDelta,
        scrollDirection,
        scrollThreshold,
        scrollDeltaThreshold,
        isAboveThreshold: currentScrollY <= scrollThreshold,
        isDeltaSignificant: Math.abs(scrollDelta) >= scrollDeltaThreshold,
      });
      // Update header background state based on scroll position
      applyHeaderBackground(currentScrollY);

      // Oberhalb des Thresholds oder am Seitenanfang - Header immer sichtbar
      if (currentScrollY <= scrollThreshold) {
        dtrace('[HeaderScroll] ðŸ“œ Above threshold - keeping header visible');
        showHeader();
        lastScrollY = currentScrollY;
        ticking = false;
        return;
      }

      // Genug gescrollt fÃ¼r eine Aktion?
      if (Math.abs(currentScrollY - lastScrollY) < scrollDeltaThreshold) {
        dtrace('[HeaderScroll] ðŸ“œ Scroll delta too small - ignoring');
        ticking = false;
        return;
      }

      // Nach unten scrollen - Header ausblenden mit VerzÃ¶gerung
      if (currentScrollY > lastScrollY) {
        dtrace('[HeaderScroll] ðŸ“œ Scrolling down - scheduling header hide');

        // Bestehenden Timer lÃ¶schen wenn vorhanden
        if (hideTimeout) {
          dtrace('[HeaderScroll] ðŸ“œ Clearing existing hide timeout');
          clearTimeout(hideTimeout);
        }

        // Kurze VerzÃ¶gerung vor dem Ausblenden fÃ¼r bessere UX
        hideTimeout = window.setTimeout(() => {
          dtrace('[HeaderScroll] ðŸ“œ Hide timeout executed - hiding header');
          if (header && isVisible) {
            header.classList.add('header-hidden');
            header.classList.remove('header-visible');
            isVisible = false;
            dinfo('[HeaderScroll] âœ… Header hidden');
          }
          hideTimeout = null;
        }, 200);
      }
      // Nach oben scrollen - Header sofort einblenden
      else {
        dtrace('[HeaderScroll] ðŸ“œ Scrolling up - showing header immediately');

        if (hideTimeout) {
          dtrace('[HeaderScroll] ðŸ“œ Clearing hide timeout for immediate show');
          clearTimeout(hideTimeout);
          hideTimeout = null;
        }
        showHeader();
      }

      lastScrollY = currentScrollY;
      ticking = false;

      dtrace('[HeaderScroll] ðŸ“œ Scroll handling completed:', {
        newLastScrollY: lastScrollY,
        tickingReset: !ticking,
      });
    }

    function showHeader() {
      if (header) {
        if (!isVisible) {
          header.classList.add('header-visible');
          header.classList.remove('header-hidden');
          isVisible = true;
          applyHeaderBackground();
          dinfo('[HeaderScroll] âœ… Header shown');
        } else {
          // keep classes but avoid logging when already visible
          header.classList.add('header-visible');
          header.classList.remove('header-hidden');
        }
      } else {
        console.error('[HeaderScroll] âŒ Cannot show header - header element is null');
      }
    }

    // Event-Handler fÃ¼r Cleanup speichern
    let scrollHandler = null;
    let resizeHandler = null;

    // Optimiertes Event-Handling mit requestAnimationFrame
    dtrace('[HeaderScroll] ðŸ”— Setting up event listeners...');

    scrollHandler = function () {
      if (!ticking) {
        dtrace('[HeaderScroll] ðŸ“œ Scroll event triggered - scheduling RAF');
        window.requestAnimationFrame(function () {
          handleScroll();
        });
        ticking = true;
      } else {
        dtrace('[HeaderScroll] ðŸ“œ Scroll event throttled - already ticking');
      }
    };
    window.addEventListener('scroll', scrollHandler, { passive: true });
    dtrace('[HeaderScroll] ðŸ”— Scroll event listener attached');

    // Resize-Event - Header neu positionieren
    resizeHandler = function () {
      if (!ticking) {
        dtrace('[HeaderScroll] ðŸ“± Resize event triggered - scheduling RAF');
        window.requestAnimationFrame(function () {
          // Bei Resize immer Header zeigen
          showHeader();
          ticking = false;
        });
        ticking = true;
      } else {
        dtrace('[HeaderScroll] ðŸ“± Resize event throttled - already ticking');
      }
    };
    window.addEventListener('resize', resizeHandler, { passive: true });
    dtrace('[HeaderScroll] ðŸ”— Resize event listener attached');

    // Initial auslÃ¶sen
    dinfo('[HeaderScroll] ðŸš€ Triggering initial handleScroll...');
    handleScroll();

    dinfo('[HeaderScroll] âœ… Scroll effect initialized', {
      scrollThreshold,
      scrollDeltaThreshold,
      hasScrollHandler: !!scrollHandler,
      hasResizeHandler: !!resizeHandler,
      initialScrollY: window.scrollY,
      headerClasses: header.className,
      dependencies: ['header-mobile-menu'],
      timestamp: new Date().toISOString(),
    });

    // Cleanup fÃ¼r Event-Listener global verfÃ¼gbar machen
    window.headerScrollCleanup = function () {
      if (scrollHandler) {
        window.removeEventListener('scroll', scrollHandler);
      }
      if (resizeHandler) {
        window.removeEventListener('resize', resizeHandler);
      }
      if (hideTimeout) {
        clearTimeout(hideTimeout);
      }
      dinfo('[HeaderScroll] Scroll effect cleaned up');
    };
  }

  // Direkter Aufruf wenn DOM bereit ist (funktionierendes Pattern aus Header.astro)
  if (document.readyState !== 'loading') {
    initHeaderScrollEffect();
  } else {
    document.addEventListener('DOMContentLoaded', initHeaderScrollEffect);
  }

  // Re-Init nach Astro View Transitions mit vorherigem Cleanup (doppelte Listener vermeiden)
  if (!window.__headerScrollAfterSwapBound) {
    window.__headerScrollAfterSwapBound = true;
    document.addEventListener('astro:after-swap', () => {
      try {
        if (typeof window.headerScrollCleanup === 'function') {
          window.headerScrollCleanup();
        }
      } catch (e) {
        console.warn('[HeaderScroll] Cleanup error:', e);
      }
      initHeaderScrollEffect();
    });
  }
</script>

<!-- Dummy HTML node to force Astro script compilation/injection -->
<div style="display: none;" aria-hidden="true"></div>
