---
// Separate Client-Script Component für den Header Scroll-Effekt
// Optimiert für Performance und Robustheit
---

<script is:inline nonce={Astro.locals.cspNonce}>
  /**
   * HeaderScroll - Optimierter Header-Animation für Show/Hide beim Scrollen
   * - Verbesserte Performance durch RequestAnimationFrame
   * - Optimierte Scroll-Erkennung mit Schwellenwert und Verzögerung
   * - Reduzierte DOM-Zugriffe
   * - Verwendet funktionierendes Pattern ohne script-coordinator
   */

  // Direkte Ausführung ohne coordinator (funktionierendes Pattern aus Header.astro)
  function initHeaderScrollEffect() {
    const __DEV__ =
      typeof location !== 'undefined' &&
      (location.hostname === 'localhost' || location.hostname === '127.0.0.1');
    const getFlag = () => {
      try {
        const ls = localStorage.getItem('debug.headerScroll') === '1';
        const qp = new URLSearchParams(location.search).has('debugHeader');
        return ls || qp;
      } catch {
        return false;
      }
    };
    const VERBOSE = __DEV__ && getFlag();
    const TRACE = __DEV__ && ((() => {
      try { return localStorage.getItem('debug.headerScrollTrace') === '1'; } catch { return false; }
    })());
    const dlog = (...args) => {
      if (VERBOSE) console.debug(...args);
    };
    const dinfo = (...args) => {
      if (VERBOSE) console.info(...args);
    };
    const dtrace = (...args) => {
      if (TRACE) console.debug(...args);
    };
    const dwarn = (...args) => {
      if (__DEV__) console.warn(...args);
    };
    dinfo('[HeaderScroll] 🚀 Starting header scroll effect initialization...');

    // Header-Element mit detailliertem Logging suchen
    const header = document.getElementById('site-header');
    const headerByTag = document.querySelector('header');
    const headerByClass = document.querySelector('.header');

    dlog('[HeaderScroll] 🔍 Header element detection results:', {
      headerById: !!header,
      headerByTag: !!headerByTag,
      headerByClass: !!headerByClass,
      headerClasses: header?.className || 'not found',
      headerTagName: header?.tagName || 'not found',
      allHeaders: Array.from(document.querySelectorAll('header')).map((h) => ({
        id: h.id,
        classes: h.className,
        tagName: h.tagName,
      })),
    });

    if (!header) {
      console.error('[HeaderScroll] ❌ Header element (#site-header) not found in DOM');
      dlog('[HeaderScroll] 🔍 Available header-related elements:', {
        headerByTag: !!headerByTag,
        headerByClass: !!headerByClass,
        possibleHeaders: Array.from(
          document.querySelectorAll('[id*="header"], [class*="header"]')
        ).map((el) => ({
          id: el.id,
          classes: el.className,
          tagName: el.tagName,
        })),
      });
      return;
    }

    // Variablen für Scroll-Logik
    let lastScrollY = window.scrollY;
    let ticking = false;
    let hideTimeout = null;
    const scrollThreshold = 80; // Reagiert etwas später
    const scrollDeltaThreshold = 8; // Mindestens 8px scrollen für Aktion
    let isVisible = true;

    // Header initial sichtbar machen
    header.classList.add('header-visible');
    header.classList.remove('header-hidden');

    function applyHeaderBackground(y) {
      try {
        const scrolled = (typeof y === 'number' ? y : window.scrollY) > 10;
        if (scrolled) {
          header.classList.add('header-solid');
        } else {
          header.classList.remove('header-solid');
        }
      } catch (e) {
        dwarn('[HeaderScroll] ⚠️ Failed to apply header background state:', e);
      }
    }

    function handleScroll() {
      const currentScrollY = window.scrollY;
      const scrollDelta = currentScrollY - lastScrollY;
      const scrollDirection = scrollDelta > 0 ? 'down' : 'up';

      dtrace('[HeaderScroll] 📜 Scroll event detected:', {
        currentScrollY,
        lastScrollY,
        scrollDelta,
        scrollDirection,
        scrollThreshold,
        scrollDeltaThreshold,
        isAboveThreshold: currentScrollY <= scrollThreshold,
        isDeltaSignificant: Math.abs(scrollDelta) >= scrollDeltaThreshold,
      });
      // Update header background state based on scroll position
      applyHeaderBackground(currentScrollY);

      // Oberhalb des Thresholds oder am Seitenanfang - Header immer sichtbar
      if (currentScrollY <= scrollThreshold) {
        dtrace('[HeaderScroll] 📜 Above threshold - keeping header visible');
        showHeader();
        lastScrollY = currentScrollY;
        ticking = false;
        return;
      }

      // Genug gescrollt für eine Aktion?
      if (Math.abs(currentScrollY - lastScrollY) < scrollDeltaThreshold) {
        dtrace('[HeaderScroll] 📜 Scroll delta too small - ignoring');
        ticking = false;
        return;
      }

      // Nach unten scrollen - Header ausblenden mit Verzögerung
      if (currentScrollY > lastScrollY) {
        dtrace('[HeaderScroll] 📜 Scrolling down - scheduling header hide');

        // Bestehenden Timer löschen wenn vorhanden
        if (hideTimeout) {
          dtrace('[HeaderScroll] 📜 Clearing existing hide timeout');
          clearTimeout(hideTimeout);
        }

        // Kurze Verzögerung vor dem Ausblenden für bessere UX
        hideTimeout = window.setTimeout(() => {
          dtrace('[HeaderScroll] 📜 Hide timeout executed - hiding header');
          if (header && isVisible) {
            header.classList.add('header-hidden');
            header.classList.remove('header-visible');
            isVisible = false;
            dinfo('[HeaderScroll] ✅ Header hidden');
          }
          hideTimeout = null;
        }, 200);
      }
      // Nach oben scrollen - Header sofort einblenden
      else {
        dtrace('[HeaderScroll] 📜 Scrolling up - showing header immediately');

        if (hideTimeout) {
          dtrace('[HeaderScroll] 📜 Clearing hide timeout for immediate show');
          clearTimeout(hideTimeout);
          hideTimeout = null;
        }
        showHeader();
      }

      lastScrollY = currentScrollY;
      ticking = false;

      dtrace('[HeaderScroll] 📜 Scroll handling completed:', {
        newLastScrollY: lastScrollY,
        tickingReset: !ticking,
      });
    }

    function showHeader() {
      if (header) {
        if (!isVisible) {
          header.classList.add('header-visible');
          header.classList.remove('header-hidden');
          isVisible = true;
          applyHeaderBackground();
          dinfo('[HeaderScroll] ✅ Header shown');
        } else {
          // keep classes but avoid logging when already visible
          header.classList.add('header-visible');
          header.classList.remove('header-hidden');
        }
      } else {
        console.error('[HeaderScroll] ❌ Cannot show header - header element is null');
      }
    }

    // Event-Handler für Cleanup speichern
    let scrollHandler = null;
    let resizeHandler = null;

    // Optimiertes Event-Handling mit requestAnimationFrame
    dtrace('[HeaderScroll] 🔗 Setting up event listeners...');

    scrollHandler = function () {
      if (!ticking) {
        dtrace('[HeaderScroll] 📜 Scroll event triggered - scheduling RAF');
        window.requestAnimationFrame(function () {
          handleScroll();
        });
        ticking = true;
      } else {
        dtrace('[HeaderScroll] 📜 Scroll event throttled - already ticking');
      }
    };
    window.addEventListener('scroll', scrollHandler, { passive: true });
    dtrace('[HeaderScroll] 🔗 Scroll event listener attached');

    // Resize-Event - Header neu positionieren
    resizeHandler = function () {
      if (!ticking) {
        dtrace('[HeaderScroll] 📱 Resize event triggered - scheduling RAF');
        window.requestAnimationFrame(function () {
          // Bei Resize immer Header zeigen
          showHeader();
          ticking = false;
        });
        ticking = true;
      } else {
        dtrace('[HeaderScroll] 📱 Resize event throttled - already ticking');
      }
    };
    window.addEventListener('resize', resizeHandler, { passive: true });
    dtrace('[HeaderScroll] 🔗 Resize event listener attached');

    // Initial auslösen
    dinfo('[HeaderScroll] 🚀 Triggering initial handleScroll...');
    handleScroll();

    dinfo('[HeaderScroll] ✅ Scroll effect initialized', {
      scrollThreshold,
      scrollDeltaThreshold,
      hasScrollHandler: !!scrollHandler,
      hasResizeHandler: !!resizeHandler,
      initialScrollY: window.scrollY,
      headerClasses: header.className,
      dependencies: ['header-mobile-menu'],
      timestamp: new Date().toISOString(),
    });

    // Cleanup für Event-Listener global verfügbar machen
    window.headerScrollCleanup = function () {
      if (scrollHandler) {
        window.removeEventListener('scroll', scrollHandler);
      }
      if (resizeHandler) {
        window.removeEventListener('resize', resizeHandler);
      }
      if (hideTimeout) {
        clearTimeout(hideTimeout);
      }
      dinfo('[HeaderScroll] Scroll effect cleaned up');
    };
  }

  // Direkter Aufruf wenn DOM bereit ist (funktionierendes Pattern aus Header.astro)
  if (document.readyState !== 'loading') {
    initHeaderScrollEffect();
  } else {
    document.addEventListener('DOMContentLoaded', initHeaderScrollEffect);
  }

  // Re-Init nach Astro View Transitions mit vorherigem Cleanup (doppelte Listener vermeiden)
  if (!window.__headerScrollAfterSwapBound) {
    window.__headerScrollAfterSwapBound = true;
    document.addEventListener('astro:after-swap', () => {
      try {
        if (typeof window.headerScrollCleanup === 'function') {
          window.headerScrollCleanup();
        }
      } catch (e) {
        console.warn('[HeaderScroll] Cleanup error:', e);
      }
      initHeaderScrollEffect();
    });
  }
</script>

<!-- Dummy HTML node to force Astro script compilation/injection -->
<div style="display: none;" aria-hidden="true"></div>
