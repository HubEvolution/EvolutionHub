---
// TypewriterComponent.astro
// Eine universelle Komponente für Typewriter-Animationen in mehreren Sprachen

interface TypewriterText {
  text: string;
  delay?: number;
}

interface Props {
  elementId: string; // ID des DOM-Elements, das den Typewriter-Text anzeigen soll
  texts: TypewriterText[]; // Array von Texten und ggf. Delays
  defaultDelay?: number; // Standard-Delay für Animationen (wenn nicht pro Text definiert)
}

// Props mit Standardwerten
const { 
  elementId = "typewriter", 
  texts = [], 
  defaultDelay = 100 
} = Astro.props;
---

<!-- Kein direktes Markup nötig, nur das Client-Script -->
<script is:inline define:vars={{ elementId, texts, defaultDelay }} nonce={Astro.locals.cspNonce}>
  // Typewriter-Funktion direkt hier definieren
  const runTypewriter = (targetElementId, textArray, baseDelay = 100) => {
    const element = document.getElementById(targetElementId);
    if (!element) {
      console.error(`Element with ID "${targetElementId}" not found.`);
      return;
    }

    // Fallback für leeres Array
    if (!textArray || textArray.length === 0) {
      textArray = [{ text: "No text provided", delay: baseDelay }];
    }

    // Sicherstellen, dass bei jedem Start frisch begonnen wird
    element.textContent = '';

    let currentIndex = 0;
    let charIndex = 0;
    let typingTimeout;

    // Text-Zeichen für Zeichen anzeigen
    const type = () => {
      if (currentIndex < textArray.length) {
        const currentText = textArray[currentIndex].text;
        if (charIndex < currentText.length) {
          element.textContent += currentText.charAt(charIndex);
          charIndex++;
          typingTimeout = setTimeout(type, baseDelay);
        } else {
          // Nach dem Tippen eines Textes eine Weile warten, bevor gelöscht wird
          setTimeout(erase, textArray[currentIndex].delay || baseDelay * 5);
        }
      }
    };

    // Text-Zeichen für Zeichen löschen
    const erase = () => {
      if (charIndex > 0) {
        element.textContent = element.textContent.slice(0, -1);
        charIndex--;
        typingTimeout = setTimeout(erase, baseDelay / 2);
      } else {
        // Nach dem Löschen zum nächsten Text wechseln
        currentIndex++;
        if (currentIndex >= textArray.length) {
          currentIndex = 0; // Zurück zum Anfang springen
        }
        const nextDelay = textArray[currentIndex].delay || baseDelay;
        typingTimeout = setTimeout(type, nextDelay);
      }
    };

    // Animation starten
    type();

    // Aufräumen bei Komponentenentfernung
    return () => {
      if (typingTimeout) {
        clearTimeout(typingTimeout);
      }
    };
  };

  // Animation robust starten und nach Astro-View-Transitions neu binden
  let cleanup = null;
  function startTypewriter() {
    try {
      if (typeof cleanup === 'function') cleanup();
    } catch (e) {
      console.warn('[Typewriter] Cleanup failed or not set:', e);
    }
    cleanup = runTypewriter(elementId, texts, defaultDelay);
  }

  if (document.readyState !== 'loading') {
    startTypewriter();
  } else {
    document.addEventListener('DOMContentLoaded', startTypewriter, { once: true });
  }

  // Nach Astro View Transitions neu starten (pro Element-ID nur einmal binden)
  (function bindAfterSwapOnce() {
    const key = `__tw_after_swap_${elementId}`;
    if (!window[key]) {
      window[key] = true;
      document.addEventListener('astro:after-swap', startTypewriter);
    }
  })();

  // Fallback: falls DOMContentLoaded verpasst wurde
  window.addEventListener('load', () => {
    if (!cleanup) startTypewriter();
  }, { once: true });
</script>
